Assuming you want to generate migration files for these classes to create tables in a database using Spring Boot, you can use the following steps:

Add necessary dependencies to your pom.xml file:
xml


<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
   <groupId>com.h2database</groupId>
   <artifactId>h2</artifactId>
   <scope>runtime</scope>
</dependency>
Configure your database connection in application.properties file:
javascript
Copy code
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.h2.console.enabled=true
Use the following commands to generate migration files:
c
Copy code
spring.jpa.hibernate.ddl-auto=create
spring.datasource.initialization-mode=always
Run your Spring Boot application. Migration files will be generated automatically when the application starts up.

Check your database tables to confirm if the tables have been created successfully.

Note: You can also use tools like Flyway or Liquibase to manage database migrations in a more controlled manner.




vikrantgopewar1969@gmail.com
regerate above code using mysql database
To generate migration files for the given classes to create tables in a MySQL database using Spring Boot, you can follow these steps:

Add necessary dependencies to your pom.xml file:
xml
Copy code
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
   <groupId>mysql</groupId>
   <artifactId>mysql-connector-java</artifactId>
   <scope>runtime</scope>
</dependency>
Configure your database connection in application.properties file:
cpp
Copy code
spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name
spring.datasource.username=your_username
spring.datasource.password=your_password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.hibernate.ddl-auto=create
Use the following commands to generate migration files:
c
Copy code
spring.jpa.hibernate.ddl-auto=create
spring.datasource.initialization-mode=always
Run your Spring Boot application. Migration files will be generated automatically when the application starts up.

Check your MySQL database tables to confirm if the tables have been created successfully.

Note: You can also use tools like Flyway or Liquibase to manage database migrations in a more controlled manner.




vikrantgopewar1969@gmail.com
regenerate above code using flyway
To generate migration files for the given classes to create tables in a MySQL database using Flyway in Spring Boot, you can follow these steps:

Add necessary dependencies to your pom.xml file:
xml
Copy code
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
   <groupId>mysql</groupId>
   <artifactId>mysql-connector-java</artifactId>
   <scope>runtime</scope>
</dependency>
<dependency>
   <groupId>org.flywaydb</groupId>
   <artifactId>flyway-core</artifactId>
   <version>7.15.0</version>
</dependency>
Configure your database connection in application.properties file:
javascript
Copy code
spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name
spring.datasource.username=your_username
spring.datasource.password=your_password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
Create a db/migration folder in your project's root directory.

Add Flyway migration scripts in the db/migration folder with the following naming convention: V{version}__{description}.sql

For example, you can create a migration script named V1__create_customer_table.sql with the following content:

sql
Copy code
CREATE TABLE customer_tbl (
    customerNumber INT PRIMARY KEY AUTO_INCREMENT,
    customerFirstName VARCHAR(255) NOT NULL,
    customerLastName VARCHAR(255) NOT NULL,
    phone BIGINT NOT NULL,
    addressLine1 VARCHAR(255) NOT NULL,
    addressLine2 VARCHAR(50),
    city VARCHAR(255) NOT NULL,
    state VARCHAR(255) NOT NULL,
    postalCode INT NOT NULL,
    country VARCHAR(255) NOT NULL
);
Similarly, you can create migration scripts for other tables.

Run your Spring Boot application. Flyway will automatically detect and execute the migration scripts.

Check your MySQL database tables to confirm if the tables have been created successfully.

Note: You can use Flyway's command-line interface or Maven plugin to manage database migrations outside of your Spring Boot application as well.





To use Elasticsearch in Spring Boot, you can follow these steps:

Add the following dependencies to your pom.xml file:
xml
Copy code
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
</dependency>

<dependency>
    <groupId>org.elasticsearch.client</groupId>
    <artifactId>elasticsearch-rest-high-level-client</artifactId>
    <version>7.16.3</version>
</dependency>
Configure Elasticsearch in your application.properties file:
properties
Copy code
spring.data.elasticsearch.cluster-name=my-cluster
spring.data.elasticsearch.cluster-nodes=localhost:9300
Create a repository interface that extends ElasticsearchRepository. For example,
to create a repository for Customer class, create an interface like this:
java
Copy code
public interface CustomerRepository extends ElasticsearchRepository<Customer, String> {
    List<Customer> findByCustomerFirstName(String firstName);
    List<Customer> findByAddressLine1(String addressLine1);
}
Inject the CustomerRepository into your service or controller class and use it to interact with
Elasticsearch:
java
Copy code
@Service
public class CustomerService {

    @Autowired
    private CustomerRepository customerRepository;

    public List<Customer> searchByFirstName(String firstName) {
        return customerRepository.findByCustomerFirstName(firstName);
    }

    public List<Customer> searchByAddressLine1(String addressLine1) {
        return customerRepository.findByAddressLine1(addressLine1);
    }
}
You can now use the CustomerService to search for customers by their first name or address line 1. For example, to search for customers with the first name "John":
java
Copy code
List<Customer> customers = customerService.searchByFirstName("John");
Note: This is just a basic example of how to use Elasticsearch in Spring Boot.
You can customize the configuration and queries to fit your needs. Also, remember to properly handle
exceptions and errors that can occur when using Elasticsearch.





Here is an example Docker Compose file for a Spring Boot application with MySQL, Redis, and Elasticsearch:



yaml
Copy code




version: '3.9'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    image: spring-boot-app
    container_name: spring-boot-app
    ports:
      - "8080:8080"
    depends_on:
      - db
      - redis
      - elasticsearch
    environment:
      - SPRING_DATASOURCE_URL=jdbc:mysql://db:3306/mydatabase
      - SPRING_DATASOURCE_USERNAME=root
      - SPRING_DATASOURCE_PASSWORD=password
      - REDIS_HOST=redis
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200

  db:
    image: mysql:latest
    container_name: mysql-db
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=mydatabase
      - MYSQL_USER=root
      - MYSQL_PASSWORD=password
    volumes:
      - db_data:/var/lib/mysql

  redis:
    image: redis:latest
    container_name: redis
    ports:
      - "6379:6379"

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.3
    container_name: elasticsearch
    ports:
      - "9200:9200"
    environment:
      - discovery.type=single-node
      - bootstrap.memory_lock=true
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ulimits:
      memlock:
        soft: -1
        hard: -1
    volumes:
      - es_data:/usr/share/elasticsearch/data

volumes:
  db_data:
  es_data:
This Docker Compose file defines four services:





app: The Spring Boot application container, which depends on the db, redis, and elasticsearch container
s. It sets environment variables for the database connection, Redis host, and Elasticsearch hosts.

db: The MySQL database container, which exposes port 3306 and sets environment variables for the root
password, database name, and credentials.

redis: The Redis container, which exposes port 6379.

elasticsearch: The Elasticsearch container, which exposes port 9200 and sets environment variables for
 single-node discovery and Java memory settings. It also mounts a volume for Elasticsearch data.

The volumes section defines two named volumes for persisting MySQL and Elasticsearch data.

Note that you may need to adjust the configuration of each service according to your specific needs,
such as the version of the software or the container names.






@RestController
@RequestMapping("/order")
public class OrderController {

    @Autowired
    private IOrderService orderService;

    @Autowired
    private ICustomerService customerService;

    @Autowired
    private IProductService productService;

    @Autowired
    private ModelMapper modelMapper;

    @PostMapping("/ord")
    @Transactional
    public ResponseEntity<OrderDto> createOrder(@Valid @RequestBody OrderDto orderDto) {
        Order order = modelMapper.map(orderDto, Order.class);
        order.setComments(orderDto.getComments());
        Customer customer = customerService.getCustomerByNumber(orderDto.getCustomerNumber());
        if (customer == null) {
            throw new IllegalArgumentException("Customer not found");
        }
        order.setCustomer(customer);
        order.setCustomerNumber(customer.getCustomerNumber());

        List<OrderDetails> orderDetailsList = new ArrayList<>();
        BigDecimal totalAmount = BigDecimal.ZERO;

        for (OrderDetailsDto orderDetailsDto : orderDto.getOrderDetails()) {
            Product product = productService.getProductByCode(orderDetailsDto.getProductCode());
            if (product == null) {
                throw new IllegalArgumentException("Product not found");
            }
            if (product.getQuantityInStock() < orderDetailsDto.getQuantityOrdered()) {
                throw new IllegalArgumentException("Product is out of stock");
            }
            product.setQuantityInStock(product.getQuantityInStock() - orderDetailsDto.getQuantityOrdered());
            OrderDetails orderDetails = modelMapper.map(orderDetailsDto, OrderDetails.class);
            orderDetails.setProduct(product);
            orderDetails.setOrder(order);
            orderDetails.setOrderNumber(order.getOrderNumber());
            orderDetails.setProductCode(product.getProductCode());
            orderDetails.setQuantityOrdered(orderDetailsDto.getQuantityOrdered());
            orderDetails.setPriceEach(product.getPrice());
            totalAmount = totalAmount.add(orderDetails.getPriceEach().multiply(BigDecimal.valueOf(orderDetails.getQuantityOrdered())));
            orderDetailsList.add(orderDetails);
        }

        order.setOrderDetails(orderDetailsList);
        order.setTotalAmount(totalAmount);
        Order savedOrder = orderService.saveOrder(order);
        OrderDto savedOrderDto = modelMapper.map(savedOrder, OrderDto.class);
        return new ResponseEntity<>(savedOrderDto, HttpStatus.OK);
    }
}








    public ResponseEntity<OrderDto> createOrder(@Valid OrderDto orderDto) {
        Order order = modelMapper.map(orderDto, Order.class);
        order.setComments(orderDto.getComments());
        Customer customer = iCustomerRepo.findById(orderDto.getCustomerNumber())
                .orElseThrow(() -> new IllegalArgumentException("Customer not found"));
        order.setCustomerNumber(customer.getCustomerNumber());
        order.setCustomer(customer);
        //order.setCustomerNumber(customer.getCustomerNumber());
        Order savedOrder = iOrderRepo.save(order);

        List<OrderDetailsDto> orderDetailsDtoList = orderDto.getOrderDetails();
        List<OrderDetails> orderDetailsList = orderDetailsDtoList.stream()
                .map(orderDetailsDto -> {
                    Product product = productRepo.findById(orderDetailsDto.getProductCode())
                            .orElseThrow(() -> new IllegalArgumentException("Product not found"));
                    if (product.getQuantityInStock() < orderDetailsDto.getQuantityOrdered()) {
                        throw new IllegalArgumentException("Product is out of stock");
                    }
                    product.setQuantityInStock(product.getQuantityInStock() - orderDetailsDto.getQuantityOrdered());
                    productRepo.save(product);
                    OrderDetails orderDetails = modelMapper.map(orderDetailsDto, OrderDetails.class);
                    orderDetails.setOrderNumber(product.getProductCode());
                    orderDetails.setProductCode(savedOrder.getOrderNumber());
                    orderDetails.setOrder(savedOrder);
                    orderDetails.setProduct(product);
                    orderDetails.setQuantityOrdered(orderDetailsDto.getQuantityOrdered());
                    orderDetails.setPriceEach(product.getPrice());
                    return iOrderDetailsRepo.save(orderDetails);
                })
                .collect(Collectors.toList());

        OrderDto savedOrderDto = modelMapper.map(savedOrder, OrderDto.class);
        savedOrderDto.setOrderDetails(orderDetailsList.stream()
                .map(orderDetails -> modelMapper.map(orderDetails, OrderDetailsDto.class))
                .collect(Collectors.toList()));

        return ResponseEntity.ok(savedOrderDto);
    }
}




A network is a collection of devices that are connected together to enable communication and data sharing between them. The devices can include computers, servers, routers, switches, and other networking hardware.

There are different types of networks, including:

Local Area Network (LAN): A LAN is a network that connects devices within a limited geographical area, such as a home, office, or school. LANs can be wired or wireless, and they typically use Ethernet cables or Wi-Fi to connect devices.

Wide Area Network (WAN): A WAN is a network that covers a large geographical area, such as a city, country, or even the entire world. WANs use telecommunication technologies, such as leased lines, satellite links, and internet connections to connect devices.

Metropolitan Area Network (MAN): A MAN is a network that covers a larger area than a LAN but smaller than a WAN. It is typically used to connect multiple LANs within a city or town.

Personal Area Network (PAN): A PAN is a network that connects devices that are located in close proximity to each other, such as a computer and a smartphone. Bluetooth and infrared technologies are commonly used to create PANs.

Networks can also be categorized by their topology, which refers to the physical layout of the devices and the way they are connected. Common topologies include bus, star, ring, and mesh.

Networks play a vital role in enabling communication, collaboration, and data sharing between devices and users. They are used in a wide range of applications, including business, education, healthcare, entertainment, and more.




The OSI (Open Systems Interconnection) model is a conceptual model that describes the communication process between two devices in a network. It divides the communication process into seven layers, each with its own set of protocols, functions, and services. The layers are:

Physical Layer: This layer deals with the physical connection between devices and includes the cabling, connectors, and other hardware components.

Data Link Layer: This layer is responsible for transferring data between devices on the same network. It also handles error detection and correction.

Network Layer: This layer is responsible for routing data between different networks. It determines the best path for data to travel based on network conditions and other factors.

Transport Layer: This layer ensures that data is transmitted reliably and efficiently. It handles issues such as flow control, error recovery, and congestion control.

Session Layer: This layer establishes and manages communication sessions between devices. It also handles issues such as session termination and synchronization.

Presentation Layer: This layer handles data formatting and presentation issues such as data compression, encryption, and decryption.

Application Layer: This layer provides services and interfaces to application programs. It includes protocols such as HTTP, FTP, SMTP, and others that enable applications to communicate over a network.

The OSI model provides a framework for understanding how communication works between devices in a network. Each layer builds upon the layer below it, and each layer is responsible for a specific set of functions and services. By breaking down the communication process into distinct layers, the OSI model makes it easier to troubleshoot network problems and develop new protocols and technologies.


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.example.demo.exception.ObjectDoesNotExist;
import com.example.demo.exception.OutOfStockException;
import com.example.demo.models.Customer;
import com.example.demo.models.Order;
import com.example.demo.models.OrderDetail;
import com.example.demo.models.Product;
import com.example.demo.repositories.OrderRepository;
import com.example.demo.repositories.ProductRepository;
import java.util.List;

@Service
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;
    @Autowired
    private ProductRepository productRepository;

    public Order createOrder(Order order) {
        List<OrderDetail> orderDetails = order.getOrderDetails();
        Order newOrder = orderRepository.save(order);

        try {
            for (OrderDetail orderDetail : orderDetails) {
                Product product = productRepository.findById(orderDetail.getProductCode().getId()).orElseThrow(ObjectDoesNotExist::new);
                int quantityOrdered = orderDetail.getQuantityOrdered();
                if (quantityOrdered <= product.getQuantityInStock()) {
                    product.setQuantityInStock(product.getQuantityInStock() - quantityOrdered);
                    productRepository.save(product);
                    OrderDetail newOrderDetail = new OrderDetail();
                    newOrderDetail.setOrderNumber(newOrder);
                    newOrderDetail.setProductCode(product);
                    newOrderDetail.setQuantityOrdered(quantityOrdered);
                    newOrderDetail.setPriceEach(product.getPrice());
                    orderRepository.save(newOrderDetail);
                } else {
                    throw new OutOfStockException();
                }
            }
            return newOrder;
        } catch (ObjectDoesNotExist e) {
            throw new ObjectDoesNotExist();
        } catch (OutOfStockException e) {
            throw new OutOfStockException();
        }
    }
}





@RestController
public class UserController {

    @Autowired
    private UserService userService;

    @PostMapping("/users")
    public ResponseEntity<Object> createUser(@RequestBody User user) {
        try {
            userService.save(user);
            return new ResponseEntity<>("User created successfully", HttpStatus.OK);
        } catch (ResourceNotFoundException ex) {
            ErrorDetails errorDetails = ex.getErrorDetails();
            return new ResponseEntity<>(errorDetails.getMessage(), HttpStatus.NOT_FOUND);
        } catch (MethodArgumentNotValidException ex) {
            ErrorDetails errorDetails = ((MethodArgumentNotValidException) ex).getErrorDetails();
            return new ResponseEntity<>(errorDetails.getMessage(), HttpStatus.BAD_REQUEST);
        } catch (Exception ex) {
            ErrorDetails errorDetails = ex.getErrorDetails();
            return new ResponseEntity<>(errorDetails.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
}





public class ErrorCode {
    public static final Map<String, String> RESPONSE_CODE = new HashMap<String, String>() {{
        put("data_not_created", "RAERR_480");
        put("data_not_found", "RAERR_481");
        put("required_field", "RAERR_482");
        put("update_failed", "RAERR_483");
        put("delete_failed", "RAERR_484");
        put("request_failed", "RAERR_485");
        put("json_parse_error", "RAERR_486");
        put("serializer_error", "RAERR_487");
        put("server_error", "RAERR_500");
        put("field_error", "RAERR_488");
    }};
}

public class ResponseMessage {
    public static final Map<String, String> MESSAGE = new HashMap<String, String>() {{
        put("data_not_created", "Data Not Created");
        put("data_not_found", "Data Not Found");
        put("required_field", "Required Field");
        put("update_failed", "Update Failed");
        put("delete_failed", "Delete Failed");
        put("request_failed", "Json Request Failed");
        put("json_parse_error", "Json Parse Error");
        put("serializer_error", "Serializer Error");
        put("field_error", "Field Error");
        put("server_error", "Something Went Wrong");
        put("success", "Success Response");
    }};
}

import org.springframework.http.HttpStatus;
public class ResponseStatus {
    public static final Map<String, HttpStatus> STATUS_CODE = new HashMap<String, HttpStatus>() {{
        put("data_not_created", HttpStatus.INTERNAL_SERVER_ERROR);
        put("data_not_found", HttpStatus.NOT_FOUND);
        put("required_field", HttpStatus.UNPROCESSABLE_ENTITY);
        put("update_failed", HttpStatus.BAD_REQUEST);
        put("delete_failed", HttpStatus.BAD_REQUEST);
        put("request_failed", HttpStatus.UNPROCESSABLE_ENTITY);
        put("json_parse_error", HttpStatus.UNPROCESSABLE_ENTITY);
        put("serializer_error", HttpStatus.UNPROCESSABLE_ENTITY);
        put("field_error", HttpStatus.INTERNAL_SERVER_ERROR);
        put("server_error", HttpStatus.INTERNAL_SERVER_ERROR);
    }};
}


import org.springframework.http.ResponseEntity;
public class CustomResponse {
    public static ResponseEntity<Object> response(String code, Object data) {
        // Create the response data object
        Map<String, Object> responseData = new HashMap<String, Object>();
        responseData.put("success", true);

        // Handle error code
        String errorCode = ErrorCodes.RESPONSE_CODE.get(code);
        if (errorCode != null) {
            responseData.put("success", false);
            responseData.put("error_code", errorCode);
        }

        // Handle error message
        String errorMessage = ResponseMessages.MESSAGE.get(code);
        if (errorMessage != null) {
            responseData.put("message", Collections.singletonList(errorMessage));
        }

        // Handle data
        if (data != null) {
            responseData.put("data", data);
        }

        HttpStatus httpStatus = ResponseStatus.STATUS_CODE.get(code);
        return new ResponseEntity<>(responseData, httpStatus);
    }
}










---------------------------------------------------------------29/03/2022--------------------------------------

SELECT p FROM Product p
WHERE p.productCode IN :productCodes
AND p.quantityInStock >= :requestedQuantity





List<Integer> productCodes = request.getOrderDetails().stream()
    .map(OrderDetail::getProductCode)
    .collect(Collectors.toList());

EntityManager em = // obtain EntityManager from EntityManagerFactory
Query query = em.createQuery("SELECT p FROM Product p WHERE p.productCode IN :productCodes AND p.quantityInStock >= :requestedQuantity");
for (OrderDetail orderDetail : request.getOrderDetails()) {
    query.setParameter("productCodes", productCodes);
    query.setParameter("requestedQuantity", orderDetail.getQuantityOrder());
    List<Product> products = query.getResultList();
    if (products.isEmpty()) {
        // requested quantity for this product is not available in stock
    } else {
        // requested quantity for this product is available in stock
    }
}




UPDATE Product p
SET p.quantityInStock = p.quantityInStock - :requestedQuantity
WHERE p.productCode IN :productCodes
AND p.quantityInStock >= :requestedQuantity




UPDATE Product p
SET p.quantityInStock = p.quantityInStock - :quantityOrder
WHERE p.productCode IN :productCodes
AND p.quantityInStock >= :quantityOrder


List<Integer> productCodes = request.getOrderDetails().stream()
    .map(OrderDetail::getProductCode)
    .collect(Collectors.toList());

EntityManager em = // obtain EntityManager from EntityManagerFactory
Query query = em.createQuery("UPDATE Product p SET p.quantityInStock = p.quantityInStock - :quantityOrder WHERE p.productCode IN :productCodes AND p.quantityInStock >= :quantityOrder");

em.getTransaction().begin();
for (OrderDetail orderDetail : request.getOrderDetails()) {
    query.setParameter("productCodes", productCodes);
    query.setParameter("quantityOrder", orderDetail.getQuantityOrder());
    int rowsAffected = query.executeUpdate();
    if (rowsAffected == 0) {
        // requested quantity for this product is not available in stock
        em.getTransaction().rollback();
        // Return an appropriate response to the client indicating that the requested quantity is not available in stock.
        return;
    }
}
em.getTransaction().commit();
// Return a success response to the client indicating that the order has been placed and the stock quantities have been updated.


import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

import java.util.*;

import org.junit.jupiter.api.*;
import org.mockito.*;

public class ProductServiceImplTest {

    @Mock
    private IProductRepo iProductRepo;

    @InjectMocks
    private ProductServiceImpl productServiceImpl;

    @BeforeEach
    void setup() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testCreateProduct() {
        // arrange
        Product product = new Product();
        when(iProductRepo.save(product)).thenReturn(product);

        // act
        Product createdProduct = productServiceImpl.createProduct(product);

        // assert
        assertEquals(product, createdProduct);
        verify(iProductRepo, times(1)).save(product);
    }

    @Test
    public void testCreateProductList() {
        // arrange
        List<Product> productList = new ArrayList<>();
        when(iProductRepo.saveAll(productList)).thenReturn(productList);

        // act
        List<Product> createdProductList = productServiceImpl.createProductList(productList);

        // assert
        assertEquals(productList, createdProductList);
        verify(iProductRepo, times(1)).saveAll(productList);
    }

    @Test
    public void testUpdateProduct() {
        // arrange
        Integer productCode = 1;
        Product existingProduct = new Product();
        existingProduct.setProductName("Product 1");
        existingProduct.setProductDescription("Description 1");
        existingProduct.setQuantityInStock(10);
        existingProduct.setPrice(100.0);
        Product updatedProduct = new Product();
        updatedProduct.setProductName("Product 1 Updated");
        updatedProduct.setProductDescription("Description 1 Updated");
        updatedProduct.setQuantityInStock(20);
        updatedProduct.setPrice(200.0);
        when(iProductRepo.findById(productCode)).thenReturn(Optional.of(existingProduct));
        when(iProductRepo.save(existingProduct)).thenReturn(existingProduct);

        // act
        Product result = productServiceImpl.updateProduct(productCode, updatedProduct);

        // assert
        assertEquals(updatedProduct.getProductName(), result.getProductName());
        assertEquals(updatedProduct.getProductDescription(), result.getProductDescription());
        assertEquals(updatedProduct.getQuantityInStock(), result.getQuantityInStock());
        assertEquals(updatedProduct.getPrice(), result.getPrice());
        verify(iProductRepo, times(1)).findById(productCode);
        verify(iProductRepo, times(1)).save(existingProduct);
    }

    @Test
    public void testUpdateProductWithInvalidProductCode() {
        // arrange
        Integer productCode = 1;
        Product updatedProduct = new Product();
        updatedProduct.setProductName("Product 1 Updated");
        updatedProduct.setProductDescription("Description 1 Updated");
        updatedProduct.setQuantityInStock(20);
        updatedProduct.setPrice(200.0);
        when(iProductRepo.findById(productCode)).thenReturn(Optional.empty());

        // act and assert
        assertThrows(IllegalArgumentException.class, () -> {
            productServiceImpl.updateProduct(productCode, updatedProduct);
        });
        verify(iProductRepo, times(1)).findById(productCode);
        verify(iProductRepo, never()).save(any());
    }

    @Test
    public void testPartialUpdate() {
        // arrange
        Integer productCode = 1;
        Map<String, Object> updates = new HashMap<>();
        updates.put("productName", "Product 1 Updated");
        updates.put("productDescription", "Description 1 Updated");
        Product existingProduct = new Product();
        existingProduct.setProductName("Product 1");
        existingProduct.setProductDescription("Description 1");
        when(iProductRepo.findById(productCode)).
}



import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ListOperations {

    public static <T extends Comparable<T>> List<T> sortList(List<T> list) {
        if(list == null) {
            return null;
        }
        Collections.sort(list);
        return list;
    }

    public static <T> List<T> reverseList(List<T> list) {
        if(list == null) {
            return null;
        }
        Collections.reverse(list);
        return list;
    }

}


import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;

public class ListOperationsTest {

    private List<Integer> integerList;
    private List<String> stringList;

    @BeforeEach
    public void setUp() {
        integerList = new ArrayList<>();
        integerList.add(4);
        integerList.add(2);
        integerList.add(1);
        integerList.add(3);

        stringList = new ArrayList<>();
        stringList.add("apple");
        stringList.add("banana");
        stringList.add("carrot");
    }

    @Test
    public void testSortList() {
        // Test sorting of integer list
        List<Integer> sortedIntegerList = ListOperations.sortList(integerList);
        assertEquals(Arrays.asList(1, 2, 3, 4), sortedIntegerList);

        // Test sorting of string list
        List<String> sortedStringList = ListOperations.sortList(stringList);
        assertEquals(Arrays.asList("apple", "banana", "carrot"), sortedStringList);

        // Test sorting of empty list
        List<String> emptyList = new ArrayList<>();
        List<String> sortedEmptyList = ListOperations.sortList(emptyList);
        assertEquals(Collections.emptyList(), sortedEmptyList);

        // Test sorting of null list
        List<String> nullList = null;
        List<String> sortedNullList = ListOperations.sortList(nullList);
        assertEquals(null, sortedNullList);
    }

    @Test
    public void testReverseList() {
        // Test reversal of integer list
        List<Integer> reversedIntegerList = ListOperations.reverseList(integerList);
        assertEquals(Arrays.asList(3, 1, 2, 4), reversedIntegerList);

        // Test reversal of string list
        List<String> reversedStringList = ListOperations.reverseList(stringList);
        assertEquals(Arrays.asList("carrot", "banana", "apple"), reversedStringList);

        // Test reversal of empty list
        List<String> emptyList = new ArrayList<>();
        List<String> reversedEmptyList = ListOperations.reverseList(emptyList);
        assertEquals(Collections.emptyList(), reversedEmptyList);

        // Test reversal of null list
        List<String> nullList = null;
        List<String> reversedNullList = ListOperations.reverseList(nullList);
        assertEquals(null, reversedNullList);
    }

    @Test
    public void testSortListWithMock() {
        List<Integer> mockedList = mock(List.class);
        when(mockedList.isEmpty()).thenReturn(false);
        when(mockedList.size()).thenReturn(3);
        when(mockedList.get(0)).thenReturn(2);
        when(mockedList.get(1)).thenReturn(1);
        when(mockedList.get(2)).thenReturn(3);

        List<Integer> sortedList = ListOperations.sortList(mockedList);

        assertEquals(Arrays.asList(1, 2);
}

@Service
public class OrderDetailsService {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private OrderDetailsRepository orderDetailsRepo;

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Transactional
    public void createOrderDetails(List<OrderDetails> orderDetailsList) throws Exception {

        Job job = jobBuilderFactory.get("createOrderDetailsJob")
                .incrementer(new RunIdIncrementer())
                .flow(step1(orderDetailsList))
                .end()
                .build();

        JobExecution jobExecution = jobLauncher.run(job, new JobParameters());
        log.info("Job Execution Status : " + jobExecution.getStatus());
    }

    private Step step1(List<OrderDetails> orderDetailsList) {
        return stepBuilderFactory.get("createOrderDetailsStep")
                .<OrderDetails, OrderDetails>chunk(100)
                .reader(new ListItemReader<>(orderDetailsList))
                .writer(new OrderDetailsWriter(orderDetailsRepo))
                .build();
    }

    private static class OrderDetailsWriter implements ItemWriter<OrderDetails> {

        private final OrderDetailsRepository orderDetailsRepo;

        public OrderDetailsWriter(OrderDetailsRepository orderDetailsRepo) {
            this.orderDetailsRepo = orderDetailsRepo;
        }

        @Override
        public void write(List<? extends OrderDetails> orderDetailsList) throws Exception {
            orderDetailsRepo.saveAll(orderDetails
    }
}

@Transactional
@Override
public Order createOrder2(Order orderDTO) {
    orderDTO.setComments(orderDTO.getComments());
    Customer customer = customerService.getCustomerById(orderDTO.getCustomerNumber());
    orderDTO.setCustomer(customer);
    orderDTO.setCustomerNumber(customer.getCustomerNumber());
    orderRepo.save(orderDTO);

    List<OrderDetails> orderDetailsDTOList = orderDTO.getOrderDetails();
    List<Integer> pid = orderDetailsDTOList.stream().map(OrderDetails::getProductCode).collect(Collectors.toList());
    List<Product> products = productService.getlistbyproductCode(pid);
    log.info("product entity : "+products.toString());
    Map<Integer, Product> productMap = products.stream()
            .collect(Collectors.toMap(Product::getProductCode, product -> product));

    JobParameters jobParameters = new JobParametersBuilder()
            .addLong("time", System.currentTimeMillis())
            .toJobParameters();

    JobExecution execution = jobLauncher.run(importOrderDetailsJob(), jobParameters);
    log.info("Job finished with status : " + execution.getStatus());

    log.info("order entity : "+orderDTO.toString());
    return orderDTO;
}

@Bean
public Job importOrderDetailsJob() {
    return jobBuilderFactory.get("importOrderDetailsJob")
            .incrementer(new RunIdIncrementer())
            .start(importOrderDetailsStep())
            .build();
}

@Bean
public Step importOrderDetailsStep() {
    return stepBuilderFactory.get("importOrderDetailsStep")
            .<OrderDetails, OrderDetails>chunk(10)
            .reader(orderDetailsReader())
            .processor(orderDetailsProcessor())
            .writer(orderDetailsWriter())
            .build();
}

@Bean
public ItemReader<OrderDetails> orderDetailsReader() {
    List<OrderDetails> orderDetailsList = new ArrayList<>();
    for (OrderDetails orderDetailsDTO : orderDTO.getOrderDetails()) {
        Product product = productMap.get(orderDetailsDTO.getProductCode());
        if (product.getQuantityInStock() >= orderDetailsDTO.getQuantityOrdered()) {
            product.setQuantityInStock(product.getQuantityInStock() - orderDetailsDTO.getQuantityOrdered());
            OrderDetails orderDetails = new OrderDetails();
            orderDetails.setOrder(orderDTO);
            orderDetails.setProduct(product);
            orderDetails.setOrderNumber(orderDTO.getOrderNumber());
            orderDetails.setProductCode(product.getProductCode());
            orderDetails.setQuantityOrdered(orderDetailsDTO.getQuantityOrdered());
            orderDetails.setPriceEach(product.getPrice());
            orderDetailsList.add(orderDetails);
            log.info("orderDetails entity : " + orderDetails.toString());
        } else {
            throw new IllegalArgumentException("Product is out of stock");
        }
    }
    return new ListItemReader<>(orderDetailsList);
}

@Bean
public ItemProcessor<OrderDetails, OrderDetails> orderDetailsProcessor() {
    return orderDetails -> orderDetails;
}

@Bean
public ItemWriter<OrderDetails> orderDetailsWriter() {
    return orderDetails -> orderDetailsRepo.saveAllAndFlush(orderDetails);
    }
}

-------------------------------------03/04/2023-------------------------------------
@Autowired
private JobBuilderFactory jobBuilderFactory;

@Autowired
private StepBuilderFactory stepBuilderFactory;

@Autowired
private OrderDetailsRepository orderDetailsRepo;

@Transactional
public void createOrderDetails(List<OrderDetails> orderDetailsList) throws Exception {

    Job job = jobBuilderFactory.get("createOrderDetailsJob")
            .incrementer(new RunIdIncrementer())
            .flow(step1(orderDetailsList))
            .end()
            .build();

    JobExecution jobExecution = jobLauncher.run(job, new JobParameters());
    log.info("Job Execution Status : " + jobExecution.getStatus());
}

private Step step1(List<OrderDetails> orderDetailsList) {
    return stepBuilderFactory.get("createOrderDetailsStep")
            .<OrderDetails, OrderDetails>chunk(100)
            .reader(new ListItemReader<>(orderDetailsList))
            .writer(new OrderDetailsWriter(orderDetailsRepo))
            .build();
}

private static class OrderDetailsWriter implements ItemWriter<OrderDetails> {

    private final OrderDetailsRepository orderDetailsRepo;

    public OrderDetailsWriter(OrderDetailsRepository orderDetailsRepo) {
        this.orderDetailsRepo = orderDetailsRepo;
    }

    @Override
    public void write(List<? extends OrderDetails> orderDetailsList) throws Exception {
        orderDetailsRepo.saveAll(orderDetailsList);
    }
}
---------------------------
@Autowired
private OrderDetailsService orderDetailsService;

@Transactional
@Override
public Order createOrder2(Order orderDTO) {

    // ... your existing code ...

    List<OrderDetails> orderDetailsList = new ArrayList<>();
    for (int i = 0; i < orderDetailsDTOList.size(); i++) {
        OrderDetails orderDetailsDTO = orderDetailsDTOList.get(i);
        Product product = productMap.get(orderDetailsDTO.getProductCode());
        if (product.getQuantityInStock() >= orderDetailsDTO.getQuantityOrdered()) {
            product.setQuantityInStock(product.getQuantityInStock() - orderDetailsDTO.getQuantityOrdered());
            OrderDetails orderDetails = new OrderDetails();
            orderDetails.setOrder(orderDTO);
            orderDetails.setProduct(product);
            orderDetails.setOrderNumber(orderDTO.getOrderNumber());
            orderDetails.setProductCode(product.getProductCode());
            orderDetails.setQuantityOrdered(orderDetailsDTO.getQuantityOrdered());
            orderDetails.setPriceEach(product.getPrice());
            orderDetailsList.add(orderDetails);
            log.info("orderDetails entity : " + orderDetails.toString());
        } else {
            throw new IllegalArgumentException("Product is out of stock");
        }
    }

    orderDetailsService.createOrderDetails(orderDetailsList);

    // ... your existing code ...
}
-----------------------------------------------------
@Service
public class OrderDetailsService {

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private OrderDetailsRepository orderDetailsRepo;

    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Transactional
    public void createOrderDetails(List<OrderDetails> orderDetailsList) throws Exception {

        Job job = jobBuilderFactory.get("createOrderDetailsJob")
                .incrementer(new RunIdIncrementer())
                .flow(step1(orderDetailsList))
                .end()
                .build();

        JobExecution jobExecution = jobLauncher.run(job, new JobParameters());
        log.info("Job Execution Status : " + jobExecution.getStatus());
    }

    private Step step1(List<OrderDetails> orderDetailsList) {
        return stepBuilderFactory.get("createOrderDetailsStep")
                .<OrderDetails, OrderDetails>chunk(100)
                .reader(new ListItemReader<>(orderDetailsList))
                .writer(new OrderDetailsWriter(orderDetailsRepo))
                .build();
    }

    private static class OrderDetailsWriter implements ItemWriter<OrderDetails> {

        private final OrderDetailsRepository orderDetailsRepo;

        public OrderDetailsWriter(OrderDetailsRepository orderDetailsRepo) {
            this.orderDetailsRepo = orderDetailsRepo;
        }

        @Override
        public void write(List<? extends OrderDetails> orderDetailsList) throws Exception {
            orderDetailsRepo.saveAll(orderDetails
}
}
-------------------------------
@Transactional
@Override
public Order createOrder2(Order orderDTO) {
    orderDTO.setComments(orderDTO.getComments());
    Customer customer = customerService.getCustomerById(orderDTO.getCustomerNumber());
    orderDTO.setCustomer(customer);
    orderDTO.setCustomerNumber(customer.getCustomerNumber());
    orderRepo.save(orderDTO);

    List<OrderDetails> orderDetailsDTOList = orderDTO.getOrderDetails();
    List<Integer> pid = orderDetailsDTOList.stream().map(OrderDetails::getProductCode).collect(Collectors.toList());
    List<Product> products = productService.getlistbyproductCode(pid);
    log.info("product entity : "+products.toString());
    Map<Integer, Product> productMap = products.stream()
            .collect(Collectors.toMap(Product::getProductCode, product -> product));

    JobParameters jobParameters = new JobParametersBuilder()
            .addLong("time", System.currentTimeMillis())
            .toJobParameters();

    JobExecution execution = jobLauncher.run(importOrderDetailsJob(), jobParameters);
    log.info("Job finished with status : " + execution.getStatus());

    log.info("order entity : "+orderDTO.toString());
    return orderDTO;
}

@Bean
public Job importOrderDetailsJob() {
    return jobBuilderFactory.get("importOrderDetailsJob")
            .incrementer(new RunIdIncrementer())
            .start(importOrderDetailsStep())
            .build();
}

@Bean
public Step importOrderDetailsStep() {
    return stepBuilderFactory.get("importOrderDetailsStep")
            .<OrderDetails, OrderDetails>chunk(10)
            .reader(orderDetailsReader())
            .processor(orderDetailsProcessor())
            .writer(orderDetailsWriter())
            .build();
}

@Bean
public ItemReader<OrderDetails> orderDetailsReader() {
    List<OrderDetails> orderDetailsList = new ArrayList<>();
    for (OrderDetails orderDetailsDTO : orderDTO.getOrderDetails()) {
        Product product = productMap.get(orderDetailsDTO.getProductCode());
        if (product.getQuantityInStock() >= orderDetailsDTO.getQuantityOrdered()) {
            product.setQuantityInStock(product.getQuantityInStock() - orderDetailsDTO.getQuantityOrdered());
            OrderDetails orderDetails = new OrderDetails();
            orderDetails.setOrder(orderDTO);
            orderDetails.setProduct(product);
            orderDetails.setOrderNumber(orderDTO.getOrderNumber());
            orderDetails.setProductCode(product.getProductCode());
            orderDetails.setQuantityOrdered(orderDetailsDTO.getQuantityOrdered());
            orderDetails.setPriceEach(product.getPrice());
            orderDetailsList.add(orderDetails);
            log.info("orderDetails entity : " + orderDetails.toString());
        } else {
            throw new IllegalArgumentException("Product is out of stock");
        }
    }
    return new ListItemReader<>(orderDetailsList);
}

@Bean
public ItemProcessor<OrderDetails, OrderDetails> orderDetailsProcessor() {
    return orderDetails -> orderDetails;
}

@Bean
public ItemWriter<OrderDetails> orderDetailsWriter() {
    return orderDetails -> orderDetailsRepo.saveAllAndFlush(orderDetails);
}
------------------------logstash
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-rest</artifactId>
</dependency>

<dependency>
    <groupId>net.logstash.logback</groupId>
    <artifactId>logstash-logback-encoder</artifactId>
    <version>6.3</version>
</dependency>

application.properties
spring.data.elasticsearch.cluster-name=your-cluster-name
spring.data.elasticsearch.cluster-nodes=your-elastic-search-server-url


<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="logstash" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
        <destination>your-logstash-server-url:your-logstash-port</destination>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder" />
    </appender>

    <root level="info">
        <appender-ref ref="logstash" />
    </root>
</configuration>

With this configuration, Logback will write log messages to Logstash, which in turn can forward them to Elasticsearch for
indexing and analysis. You can then use Kibana to visualize the log data.

logging.config=/path/to/my/logback-config.xml
--------------------------------

First, you'll need to add the necessary dependencies to your project's build file. Here's an example using Gradle:
groovy
Copy code
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-batch'
    // other dependencies
}
Next, you'll need to define a Step that reads your OrderDetails objects, processes them, and writes them to the database.
Here's an example implementation:
java
Copy code
@Bean
public Step orderDetailsStep(ItemReader<OrderDetails> orderDetailsReader,
                             ItemWriter<OrderDetails> orderDetailsWriter) {
    return stepBuilderFactory.get("orderDetailsStep")
            .<OrderDetails, OrderDetails>chunk(10)
            .reader(orderDetailsReader)
            .processor(orderDetailsProcessor())
            .writer(orderDetailsWriter)
            .build();
}
This step reads OrderDetails objects in chunks of 10, processes them using a Processor, and writes them to the database using an ItemWriter. You'll need to provide implementations for the ItemReader, Processor, and ItemWriter.

The ItemReader implementation could be something like this:
java
Copy code
@Bean
public ItemReader<OrderDetails> orderDetailsReader() {
    List<OrderDetails> orderDetailsList = getOrderDetailsList(); // get the list of OrderDetails from somewhere
    return new ListItemReader<>(orderDetailsList);
}
Here, you're simply providing a list of OrderDetails objects as the input for the reader.

The Processor implementation could be something like this:
java
Copy code
@Bean
public ItemProcessor<OrderDetails, OrderDetails> orderDetailsProcessor() {
    return new ItemProcessor<OrderDetails, OrderDetails>() {
        @Override
        public OrderDetails process(OrderDetails orderDetails) throws Exception {
            Product product = getProductByCode(orderDetails.getProductCode()); // get the Product by code
            if (product.getQuantityInStock() >= orderDetails.getQuantityOrdered()) {
                product.setQuantityInStock(product.getQuantityInStock() - orderDetails.getQuantityOrdered());
                orderDetails.setProduct(product);
                orderDetails.setPriceEach(product.getPrice());
                return orderDetails;
            } else {
                throw new IllegalArgumentException("Product is out of stock");
            }
        }
    };
}
Here, you're processing each OrderDetails object by retrieving the corresponding Product from the database,
checking if it's in stock, updating its quantity, and setting the price for the OrderDetails object.
You're also throwing an exception if the product is out of stock.

The ItemWriter implementation could be something like this:
java
Copy code
@Bean
public ItemWriter<OrderDetails> orderDetailsWriter(EntityManagerFactory entityManagerFactory) {
    return new JpaItemWriterBuilder<OrderDetails>()
            .entityManagerFactory(entityManagerFactory)
            .build();
}
Here, you're using the JpaItemWriter provided by Spring Batch to write the OrderDetails objects to the database.
You'll need to provide an EntityManagerFactory bean.

Finally, you'll need to define a Job that includes the Step you defined earlier. Here's an example implementation:
java
Copy code
@Bean
public Job createOrderJob(JobBuilderFactory jobBuilderFactory, Step orderDetailsStep) {
    return jobBuilderFactory.get("createOrderJob")
            .incrementer(new RunIdIncrementer())
            .flow(orderDetailsStep)
            .end()
            .build();
}
This job includes the `orderDetailsStep
--------------------------jpa batch insert

@Transactional
@Override
public Order createOrder2(Order orderDTO) {
    orderDTO.setComments(orderDTO.getComments());
    Customer customer = customerService.getCustomerById(orderDTO.getCustomerNumber());
    orderDTO.setCustomer(customer);
    orderDTO.setCustomerNumber(customer.getCustomerNumber());
    orderRepo.save(orderDTO);
    List<OrderDetails> orderDetailsDTOList = orderDTO.getOrderDetails();
    List<Integer> pid = orderDetailsDTOList.stream().map(OrderDetails::getProductCode).collect(Collectors.toList());
    List<Product> products = productService.getlistbyproductCode(pid);
    log.info("product entity : "+products.toString());
    Map<Integer, Product> productMap = products.stream()
            .collect(Collectors.toMap(Product::getProductCode, product -> product));
    List<OrderDetails> orderDetailsList1 = new ArrayList<>();
    for (int i = 0; i < orderDetailsDTOList.size(); i++) {
        OrderDetails orderDetailsDTO = orderDetailsDTOList.get(i);
        Product product = productMap.get(orderDetailsDTO.getProductCode());
        if (product.getQuantityInStock() >= orderDetailsDTO.getQuantityOrdered()) {
            product.setQuantityInStock(product.getQuantityInStock() - orderDetailsDTO.getQuantityOrdered());
            OrderDetails orderDetails = new OrderDetails();
            orderDetails.setOrder(orderDTO);
            orderDetails.setProduct(product);
            orderDetails.setOrderNumber(orderDTO.getOrderNumber());
            orderDetails.setProductCode(product.getProductCode());
            orderDetails.setQuantityOrdered(orderDetailsDTO.getQuantityOrdered());
            orderDetails.setPriceEach(product.getPrice());
            orderDetailsList1.add(orderDetails);
            log.info("orderDetails entity : " + orderDetails.toString());
        } else {
            throw new IllegalArgumentException("Product is out of stock");
        }
    }
    orderDetailsRepo.saveAllAndFlush(orderDetailsList1);
    log.info("order entity : "+orderDTO.toString());
    return orderDTO;
}
----------------------------

spring.jpa.properties.hibernate.jdbc.batch_size=100
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true


@Transactional
@Override
public Order createOrder2(Order orderDTO) {
    orderDTO.setComments(orderDTO.getComments());
    Customer customer = customerService.getCustomerById(orderDTO.getCustomerNumber());
    orderDTO.setCustomer(customer);
    orderDTO.setCustomerNumber(customer.getCustomerNumber());
    orderRepo.save(orderDTO);

    List<OrderDetails> orderDetailsDTOList = orderDTO.getOrderDetails();
    List<Integer> pid = orderDetailsDTOList.stream().map(OrderDetails::getProductCode).collect(Collectors.toList());
    List<Product> products = productService.getlistbyproductCode(pid);
    log.info("product entity : "+products.toString());
    Map<Integer, Product> productMap = products.stream()
            .collect(Collectors.toMap(Product::getProductCode, product -> product));

    List<OrderDetails> orderDetailsList1 = new ArrayList<>();
    for (int i = 0; i < orderDetailsDTOList.size(); i++) {
        OrderDetails orderDetailsDTO = orderDetailsDTOList.get(i);
        Product product = productMap.get(orderDetailsDTO.getProductCode());
        if (product.getQuantityInStock() >= orderDetailsDTO.getQuantityOrdered()) {
            product.setQuantityInStock(product.getQuantityInStock() - orderDetailsDTO.getQuantityOrdered());
            OrderDetails orderDetails = new OrderDetails();
            orderDetails.setOrder(orderDTO);
            orderDetails.setProduct(product);
            orderDetails.setOrderNumber(orderDTO.getOrderNumber());
            orderDetails.setProductCode(product.getProductCode());
            orderDetails.setQuantityOrdered(orderDetailsDTO.getQuantityOrdered());
            orderDetails.setPriceEach(product.getPrice());
            orderDetailsList1.add(orderDetails);
            log.info("orderDetails entity : " + orderDetails.toString());
        } else {
            throw new IllegalArgumentException("Product is out of stock");
        }
    }
    orderDetailsRepo.saveAll(orderDetailsList1);
    orderDetailsRepo.flush();
    log.info("order entity : "+orderDTO.toString());
    return orderDTO;

}


-----------------------------------------------------------------04/03/2023
@Override
public Order updateOrder(Order order) {
    Order existingOrder = orderRepo.findById(order.getOrderNumber())
        .orElseThrow(() -> new IllegalArgumentException("Order does not exist"));

    existingOrder.setComments(order.getComments());
    Customer customer = customerService.getCustomerById(order.getCustomerNumber());
    existingOrder.setCustomerNumber(customer.getCustomerNumber());
    existingOrder.setCustomer(customer);

    List<OrderDetails> existingOrderDetailsList = existingOrder.getOrderDetails();
    List<OrderDetails> updatedOrderDetailsList = order.getOrderDetails();

    List<Integer> existingProductIds = existingOrderDetailsList.stream()
        .map(OrderDetails::getProductCode)
        .collect(Collectors.toList());

    List<Integer> updatedProductIds = updatedOrderDetailsList.stream()
        .map(OrderDetails::getProductCode)
        .collect(Collectors.toList());

    List<Integer> allProductIds = new ArrayList<>();
    allProductIds.addAll(existingProductIds);
    allProductIds.addAll(updatedProductIds);

    List<Product> products = iProductService.getProductList(allProductIds);

    Map<Integer, Product> productMap = products.stream()
        .collect(Collectors.toMap(Product::getProductCode, product -> product));

    List<OrderDetails> orderDetailsList = new ArrayList<>();
    for (OrderDetails orderDetailsDto : updatedOrderDetailsList) {
        Product product = productMap.get(orderDetailsDto.getProductCode());

        if (product.getQuantityInStock() < orderDetailsDto.getQuantityOrdered()) {
            throw new IllegalArgumentException("Product is out of stock");
        }
        product.setQuantityInStock(product.getQuantityInStock() - orderDetailsDto.getQuantityOrdered());

        OrderDetails existingOrderDetails = existingOrderDetailsList.stream()
            .filter(d -> d.getProductCode().equals(orderDetailsDto.getProductCode()))
            .findFirst()
            .orElse(null);

        if (existingOrderDetails != null) {
            existingOrderDetails.setQuantityOrdered(orderDetailsDto.getQuantityOrdered());
            existingOrderDetails.setPriceEach(product.getPrice());
            orderDetailsList.add(existingOrderDetails);
        } else {
            OrderDetails orderDetails = modelMapper.map(orderDetailsDto, OrderDetails.class);
            orderDetails.setProduct(product);
            orderDetails.setQuantityOrdered(orderDetailsDto.getQuantityOrdered());
            orderDetails.setPriceEach(product.getPrice());
            orderDetails.setOrderNumber(existingOrder.getOrderNumber());
            orderDetailsList.add(orderDetails);
        }
    }
    existingOrder.setOrderDetails(orderDetailsList);

    detailService.saveAll(orderDetailsList);
    orderRepo.save(existingOrder);
    return existingOrder;
}


